<?xml version="1.0" encoding="iso-8859-1"?>
<module name="Ft.Lib.Uri">
  <modification-date>2006-10-21 22:20:36</modification-date>
  <abstract>Classes and functions related to URI validation and resolution</abstract>
  <description>APIs that currently differentiate between Unicode and byte strings are
considered to be experimental; do not count on their uniformity between
releases.

Copyright 2005 Fourthought, Inc. (USA).
Detailed license and copyright information: http://4suite.org/COPYRIGHT
Project home, documentation, distributions: http://4suite.org/</description>
  <classes>
    <class name="FtUriResolver" public="yes">
      <bases>
        <base documented="yes" class="UriResolverBase" module="Ft.Lib.Uri"/>
      </bases>
      <abstract>The URI resolver class used by most of 4Suite, outside of the repository.</abstract>
      <description>Adds support for lenient processing of base URIs.</description>
      <method-resolution-order>
        <base name="FtUriResolver" module="Ft.Lib.Uri"/>
        <base name="UriResolverBase" module="Ft.Lib.Uri"/>
      </method-resolution-order>
      <methods name="UriResolverBase" module="Ft.Lib.Uri">
        <method public="no" name="normalize" id="FtUriResolver-normalize">
          <abstract>This function differs from UriResolverBase.normalize() in the
following manner:</abstract>
          <description>This function allows for the possibility of the base URI beginning
with a '/', in which case the argument is assumed to be an absolute
path component of 'file' URI that has no authority component.</description>
          <arguments>
            <arg name="self"/>
            <arg name="uriRef"/>
            <arg name="baseUri"/>
          </arguments>
          <overrides documented="yes" class="UriResolverBase" module="Ft.Lib.Uri"/>
        </method>
      </methods>
      <inherited-methods documented="yes" class="UriResolverBase" module="Ft.Lib.Uri">
        <member-reference name="__init__" public="no"/>
        <member-reference name="generate" public="no"/>
        <member-reference name="resolve" public="no"/>
      </inherited-methods>
    </class>
    <class name="UriDict" public="yes">
      <bases>
        <base documented="no" class="dict"/>
      </bases>
      <abstract>A dictionary that uses URIs as keys. It attempts to observe some degree of
URI equivalence as defined in RFC 3986 section 6. For example, if URIs
A and B are equivalent, a dictionary operation involving key B will return
the same result as one involving key A, and vice-versa.</abstract>
      <description>This is useful in situations where retrieval of a new representation of a
resource is undesirable for equivalent URIs, such as &quot;file:///x&quot; and
&quot;file://localhost/x&quot; (see RFC 1738), or &quot;http://spam/~x/&quot;,
&quot;http://spam/%7Ex/&quot; and &quot;http://spam/%7ex&quot; (see RFC 3986).

Normalization performed includes case normalization on the scheme and
percent-encoded octets, percent-encoding normalization (decoding of
octets corresponding to unreserved characters), and the reduction of
'file://localhost/' to 'file:///', in accordance with both RFC 1738 and
RFC 3986 (although RFC 3986 encourages using 'localhost' and doing
this for all schemes, not just file).

An instance of this class is used by Ft.Xml.Xslt.XsltContext for caching
documents, so that the XSLT function document() will return identical
nodes, without refetching/reparsing, for equivalent URIs.</description>
      <method-resolution-order>
        <base name="UriDict" module="Ft.Lib.Uri"/>
        <base name="dict"/>
        <base name="object"/>
      </method-resolution-order>
      <methods name="object">
        <method public="no" name="__contains__" id="UriDict-__contains__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="key"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="__delitem__" id="UriDict-__delitem__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="key"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="__getitem__" id="UriDict-__getitem__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="key"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="__iter__" id="UriDict-__iter__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="__setitem__" id="UriDict-__setitem__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="key"/>
            <arg name="value"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="has_key" id="UriDict-has_key">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="key"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" name="iteritems" id="UriDict-iteritems">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
        <method public="no" realid="UriDict-__iter__" name="iterkeys" realname="__iter__" id="UriDict-iterkeys">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
          </arguments>
          <overrides documented="no" class="dict"/>
        </method>
      </methods>
      <members name="object">
        <member public="no" name="__dict__" id="UriDict-__dict__">
          <value>&lt;attribute '__dict__' of 'UriDict' objects&gt;</value>
        </member>
        <member public="no" name="__weakref__" id="UriDict-__weakref__">
          <value>&lt;attribute '__weakref__' of 'UriDict' objects&gt;</value>
        </member>
      </members>
      <inherited-methods documented="no" class="dict">
        <member-reference name="__cmp__" public="no"/>
        <member-reference name="__eq__" public="no"/>
        <member-reference name="__ge__" public="no"/>
        <member-reference name="__getattribute__" public="no"/>
        <member-reference name="__gt__" public="no"/>
        <member-reference name="__hash__" public="no"/>
        <member-reference name="__init__" public="no"/>
        <member-reference name="__le__" public="no"/>
        <member-reference name="__len__" public="no"/>
        <member-reference name="__lt__" public="no"/>
        <member-reference name="__ne__" public="no"/>
        <member-reference name="__new__" public="no"/>
        <member-reference name="__repr__" public="no"/>
        <member-reference name="clear" public="no"/>
        <member-reference name="copy" public="no"/>
        <member-reference name="get" public="no"/>
        <member-reference name="items" public="no"/>
        <member-reference name="itervalues" public="no"/>
        <member-reference name="keys" public="no"/>
        <member-reference name="pop" public="no"/>
        <member-reference name="popitem" public="no"/>
        <member-reference name="setdefault" public="no"/>
        <member-reference name="update" public="no"/>
        <member-reference name="values" public="no"/>
      </inherited-methods>
      <inherited-members documented="no" class="dict">
        <member-reference name="fromkeys" public="no"/>
      </inherited-members>
      <inherited-methods documented="no" class="object">
        <member-reference name="__delattr__" public="no"/>
        <member-reference name="__reduce__" public="no"/>
        <member-reference name="__reduce_ex__" public="no"/>
        <member-reference name="__setattr__" public="no"/>
        <member-reference name="__str__" public="no"/>
      </inherited-methods>
      <inherited-members documented="no" class="object">
        <member-reference name="__class__" public="no"/>
      </inherited-members>
    </class>
    <class name="UriResolverBase" public="yes">
      <abstract>#=============================================================================
# Extendable normalization and resolution functions for URI references</abstract>
      <description/>
      <method-resolution-order>
        <base name="UriResolverBase" module="Ft.Lib.Uri"/>
      </method-resolution-order>
      <methods name="UriResolverBase" module="Ft.Lib.Uri">
        <method public="no" name="__init__" id="UriResolverBase-__init__">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
          </arguments>
        </method>
        <method public="no" name="generate" id="UriResolverBase-generate">
          <abstract>This function generates and returns a URI.
The hint is an object that helps decide what to generate.
The default action is to generate a random UUID URN.</abstract>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg default="None" name="hint"/>
          </arguments>
        </method>
        <method public="no" name="normalize" id="UriResolverBase-normalize">
          <abstract>Resolves a URI reference to absolute form, effecting the result of RFC
3986 section 5. The URI reference is considered to be relative to
the given base URI.</abstract>
          <description>Also verifies that the resulting URI reference has a scheme that
resolve() supports, raising a UriException if it doesn't.

The default implementation does not perform any validation on the base
URI beyond that performed by Absolutize().</description>
          <arguments>
            <arg name="self"/>
            <arg name="uriRef"/>
            <arg name="baseUri"/>
          </arguments>
        </method>
        <method public="no" name="resolve" id="UriResolverBase-resolve">
          <abstract>This function takes a URI or a URI reference plus a base URI, produces
a normalized URI using the normalize function if a base URI was given,
then attempts to obtain access to an entity representing the resource
identified by the resulting URI, returning the entity as a stream (a
Python file-like object).</abstract>
          <description>Raises a UriException if the URI scheme is unsupported or if a stream
could not be obtained for any reason.</description>
          <arguments>
            <arg name="self"/>
            <arg name="uri"/>
            <arg default="None" name="baseUri"/>
          </arguments>
        </method>
      </methods>
    </class>
    <class name="_DataHandler" public="no">
      <bases>
        <base documented="no" class="BaseHandler" module="urllib2"/>
      </bases>
      <abstract>A class to handle 'data' URLs.</abstract>
      <description>The actual handling is done by urllib.URLopener.open_data() method.</description>
      <method-resolution-order>
        <base name="_DataHandler" module="Ft.Lib.Uri"/>
        <base name="BaseHandler" module="urllib2"/>
      </method-resolution-order>
      <methods name="BaseHandler" module="urllib2">
        <method public="no" name="data_open" id="_DataHandler-data_open">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="request"/>
          </arguments>
        </method>
      </methods>
      <inherited-methods documented="no" class="BaseHandler" module="urllib2">
        <member-reference name="__lt__" public="no"/>
        <member-reference name="add_parent" public="no"/>
        <member-reference name="close" public="no"/>
      </inherited-methods>
      <inherited-members documented="no" class="BaseHandler" module="urllib2">
        <member-reference name="handler_order" public="no"/>
      </inherited-members>
    </class>
    <class name="_Pep302Handler" public="no">
      <bases>
        <base documented="no" class="FileHandler" module="urllib2"/>
      </bases>
      <abstract>A class to handler opening of PEP 302 pseudo-URLs.</abstract>
      <description>The syntax for this pseudo-URL is:
    url    := &quot;pep302://&quot; module &quot;/&quot; path
    module := &lt;Python module name&gt;
    path   := &lt;'/'-separated pathname&gt;

The &quot;path&quot; portion of the URL will be passed to the get_data() method
of the loader identified by &quot;module&quot; with '/'s converted to the OS
native path separator.</description>
      <method-resolution-order>
        <base name="_Pep302Handler" module="Ft.Lib.Uri"/>
        <base name="FileHandler" module="urllib2"/>
        <base name="BaseHandler" module="urllib2"/>
      </method-resolution-order>
      <methods name="BaseHandler" module="urllib2">
        <method public="no" name="pep302_open" id="_Pep302Handler-pep302_open">
          <abstract/>
          <description/>
          <arguments>
            <arg name="self"/>
            <arg name="request"/>
          </arguments>
        </method>
      </methods>
      <inherited-methods documented="no" class="FileHandler" module="urllib2">
        <member-reference name="file_open" public="no"/>
        <member-reference name="get_names" public="no"/>
        <member-reference name="open_local_file" public="no"/>
      </inherited-methods>
      <inherited-members documented="no" class="FileHandler" module="urllib2">
        <member-reference name="names" public="no"/>
      </inherited-members>
      <inherited-methods documented="no" class="BaseHandler" module="urllib2">
        <member-reference name="__lt__" public="no"/>
        <member-reference name="add_parent" public="no"/>
        <member-reference name="close" public="no"/>
      </inherited-methods>
      <inherited-members documented="no" class="BaseHandler" module="urllib2">
        <member-reference name="handler_order" public="no"/>
      </inherited-members>
    </class>
  </classes>
  <functions>
    <function public="yes" name="Absolutize" id="Absolutize">
      <abstract>Resolves a URI reference to absolute form, effecting the result of RFC
3986 section 5. The URI reference is considered to be relative to the
given base URI.</abstract>
      <description>It is the caller's responsibility to ensure that the base URI matches
the absolute-URI syntax rule of RFC 3986, and that its path component
does not contain '.' or '..' segments if the scheme is hierarchical.
Unexpected results may occur otherwise.

This function only conducts a minimal sanity check in order to determine
if relative resolution is possible: it raises a UriException if the base
URI does not have a scheme component. While it is true that the base URI
is irrelevant if the URI reference has a scheme, an exception is raised
in order to signal that the given string does not even come close to
meeting the criteria to be usable as a base URI.

It is the caller's responsibility to make a determination of whether the
URI reference constitutes a &quot;same-document reference&quot;, as defined in RFC
2396 or RFC 3986. As per the spec, dereferencing a same-document
reference &quot;should not&quot; involve retrieval of a new representation of the
referenced resource. Note that the two specs have different definitions
of same-document reference: RFC 2396 says it is *only* the cases where the
reference is the empty string, or &quot;#&quot; followed by a fragment; RFC 3986
requires making a comparison of the base URI to the absolute form of the
reference (as is returned by the spec), minus its fragment component,
if any.

This function is similar to urlparse.urljoin() and urllib.basejoin().
Those functions, however, are (as of Python 2.3) outdated, buggy, and/or
designed to produce results acceptable for use with other core Python
libraries, rather than being earnest implementations of the relevant
specs. Their problems are most noticeable in their handling of
same-document references and 'file:' URIs, both being situations that
come up far too often to consider the functions reliable enough for
general use.</description>
      <arguments>
        <arg name="uriRef"/>
        <arg name="baseUri"/>
      </arguments>
    </function>
    <function public="yes" name="BaseJoin" id="BaseJoin">
      <abstract>Merges a base URI reference with another URI reference, returning a
new URI reference.</abstract>
      <description>It behaves exactly the same as Absolutize(), except the arguments
are reversed, and it accepts any URI reference (even a relative URI)
as the base URI. If the base has no scheme component, it is
evaluated as if it did, and then the scheme component of the result
is removed from the result, unless the uriRef had a scheme. Thus, if
neither argument has a scheme component, the result won't have one.

This function is named BaseJoin because it is very much like
urllib.basejoin(), but it follows the current RFC 3986 algorithms
for path merging, dot segment elimination, and inheritance of query
and fragment components.

WARNING: This function exists for 2 reasons: (1) because of a need
within the 4Suite repository to perform URI reference absolutization
using base URIs that are stored (inappropriately) as absolute paths
in the subjects of statements in the RDF model, and (2) because of
a similar need to interpret relative repo paths in a 4Suite product
setup.xml file as being relative to a path that can be set outside
the document. When these needs go away, this function probably will,
too, so it is not advisable to use it.</description>
      <arguments>
        <arg name="base"/>
        <arg name="uriRef"/>
      </arguments>
    </function>
    <function public="no" name="FileUrl" id="FileUrl">
      <abstract/>
      <description/>
      <arguments>
        <arg name="filepath"/>
      </arguments>
    </function>
    <function public="yes" name="GetScheme" id="GetScheme">
      <abstract>Obtains, with optimum efficiency, just the scheme from a URI reference.
Returns a string, or if no scheme could be found, returns None.</abstract>
      <description/>
      <arguments>
        <arg name="uriRef"/>
      </arguments>
    </function>
    <function public="yes" name="IsAbsolute" id="IsAbsolute">
      <abstract>Given a string believed to be a URI or URI reference, tests that it is
absolute (as per RFC 3986), not relative -- i.e., that it has a scheme.</abstract>
      <description/>
      <arguments>
        <arg name="identifier"/>
      </arguments>
    </function>
    <function public="yes" name="MakeUrllibSafe" id="MakeUrllibSafe">
      <abstract>Makes the given RFC 3986-conformant URI reference safe for passing
to legacy urllib functions. The result may not be a valid URI.</abstract>
      <description>As of Python 2.3.3, urllib.urlopen() does not fully support
internationalized domain names, it does not strip fragment components,
and on Windows, it expects file URIs to use '|' instead of ':' in the
path component corresponding to the drivespec. It also relies on
urllib.unquote(), which mishandles unicode arguments. This function
produces a URI reference that will work around these issues, although
the IDN workaround is limited to Python 2.3 only. May raise a
UnicodeEncodeError if the URI reference is Unicode and erroneously
contains non-ASCII characters.</description>
      <arguments>
        <arg name="uriRef"/>
      </arguments>
    </function>
    <function public="yes" name="MatchesUriRefSyntax" id="MatchesUriRefSyntax">
      <abstract>This function returns true if the given string could be a URI reference,
as defined in RFC 3986, just based on the string's syntax.</abstract>
      <description>A URI reference can be a URI or certain portions of one, including the
empty string, and it can have a fragment component.</description>
      <arguments>
        <arg name="s"/>
      </arguments>
    </function>
    <function public="yes" name="MatchesUriSyntax" id="MatchesUriSyntax">
      <abstract>This function returns true if the given string could be a URI, as defined
in RFC 3986, just based on the string's syntax.</abstract>
      <description>A URI is by definition absolute (begins with a scheme) and does not end
with a #fragment. It also must adhere to various other syntax rules.</description>
      <arguments>
        <arg name="s"/>
      </arguments>
    </function>
    <function public="yes" name="NormalizeCase" id="NormalizeCase">
      <abstract>Returns the given URI reference with the case of the scheme,
percent-encoded octets, and, optionally, the host, all normalized,
implementing section 6.2.2.1 of RFC 3986. The normal form of
scheme and host is lowercase, and the normal form of
percent-encoded octets is uppercase.</abstract>
      <description>The URI reference can be given as either a string or as a sequence as
would be provided by the SplitUriRef function. The return value will
be a string or tuple.</description>
      <arguments>
        <arg name="uriRef"/>
        <arg default="False" name="doHost"/>
      </arguments>
    </function>
    <function public="yes" name="NormalizePathSegments" id="NormalizePathSegments">
      <abstract>Given a string representing the path component of a URI reference having a
hierarchical scheme, returns the string with dot segments ('.' and '..')
removed, implementing section 6.2.2.3 of RFC 3986. If the path is
relative, it is returned with no changes.</abstract>
      <description/>
      <arguments>
        <arg name="path"/>
      </arguments>
    </function>
    <function public="yes" name="NormalizePathSegmentsInUri" id="NormalizePathSegmentsInUri">
      <abstract>Given a string representing a URI or URI reference having a hierarchical
scheme, returns the string with dot segments ('.' and '..') removed from
the path component, implementing section 6.2.2.3 of RFC 3986. If the
path is relative, the URI or URI reference is returned with no changes.</abstract>
      <description/>
      <arguments>
        <arg name="uri"/>
      </arguments>
    </function>
    <function public="yes" name="NormalizePercentEncoding" id="NormalizePercentEncoding">
      <abstract>Given a string representing a URI reference or a component thereof,
returns the string with all percent-encoded octets that correspond to
unreserved characters decoded, implementing section 6.2.2.2 of RFC
3986.</abstract>
      <description/>
      <arguments>
        <arg name="s"/>
      </arguments>
    </function>
    <function public="yes" name="OsPathToUri" id="OsPathToUri">
      <abstract>This function converts an OS-specific file system path to a URI of
the form 'file:///path/to/the/file'.</abstract>
      <description>In addition, if the path is absolute, any dot segments ('.' or '..') will
be collapsed, so that the resulting URI can be safely used as a base URI
by functions such as Absolutize().

The given path will be interpreted as being one that is appropriate for
use on the local operating system, unless a different osname argument is
given.

If the given path is relative, an attempt may be made to first convert
the path to absolute form by interpreting the path as being relative
to the current working directory.  This is the case if the attemptAbsolute
flag is True (the default).  If attemptAbsolute is False, a relative
path will result in a URI of the form file:relative/path/to/a/file .

attemptAbsolute has no effect if the given path is not for the
local operating system.

On Windows, the drivespec will become the first step in the path component
of the URI. If the given path contains a UNC hostname, this name will be
used for the authority component of the URI.

Warning: Some libraries, such as urllib.urlopen(), may not behave as
expected when given a URI generated by this function. On Windows you may
want to call re.sub('(/[A-Za-z]):', r'\1|', uri) on the URI to prepare it
for use by functions such as urllib.url2pathname() or urllib.urlopen().

This function is similar to urllib.pathname2url(), but is more featureful
and produces better URIs.</description>
      <arguments>
        <arg name="path"/>
        <arg default="True" name="attemptAbsolute"/>
        <arg default="None" name="osname"/>
      </arguments>
    </function>
    <function public="yes" name="PathResolve" id="PathResolve">
      <abstract>This function takes a list of file URIs.  The first can be
absolute or relative to the URI equivalent of the current working
directory. The rest must be relative to the first.
The function converts them all to OS paths appropriate for the local
system, and then creates a single final path by resolving each path
in the list against the following one. This final path is returned
as a URI.</abstract>
      <description/>
      <arguments>
        <arg name="paths"/>
      </arguments>
    </function>
    <function public="yes" name="PercentDecode" id="PercentDecode">
      <abstract>[*** Experimental API ***] Reverses the percent-encoding of the given
string.</abstract>
      <description>This function is similar to urllib.unquote(), but can also process a
Unicode string, not just a regular byte string.

By default, all percent-encoded sequences are decoded, but if a byte
string is given via the 'decodable' argument, only the sequences
corresponding to those octets will be decoded.

If the string is Unicode, the percent-encoded sequences are converted to
bytes, then converted back to Unicode according to the encoding given in
the encoding argument. For example, by default, u'abc%E2%80%A2' will be
converted to u'abc\u2022', because byte sequence E2 80 A2 represents
character U+2022 in UTF-8.

If the string is not Unicode, the percent-encoded octets are just
converted to bytes, and the encoding argument is ignored. For example,
'abc%E2%80%A2' will be converted to 'abcâ€¢'.

This function is intended for use on the portions of a URI that are
delimited by reserved characters (see PercentEncode), or on a value from
data of media type application/x-www-form-urlencoded.</description>
      <arguments>
        <arg name="s"/>
        <arg default="'utf-8'" name="encoding"/>
        <arg default="None" name="decodable"/>
      </arguments>
    </function>
    <function public="yes" name="PercentEncode" id="PercentEncode">
      <abstract>[*** Experimental API ***] This function applies percent-encoding, as
described in RFC 3986 sec. 2.1, to the given string, in order to prepare
the string for use in a URI. It replaces characters that are not allowed
in a URI. By default, it also replaces characters in the reserved set,
which normally includes the generic URI component delimiters &quot;:&quot; &quot;/&quot;
&quot;?&quot; &quot;#&quot; &quot;[&quot; &quot;]&quot; &quot;@&quot; and the subcomponent delimiters &quot;!&quot; &quot;$&quot; &quot;&amp;&quot; &quot;'&quot; &quot;(&quot;
&quot;)&quot; &quot;*&quot; &quot;+&quot; &quot;,&quot; &quot;;&quot; &quot;=&quot;.</abstract>
      <description>Ideally, this function should be used on individual components or
subcomponents of a URI prior to assembly of the complete URI, not
afterward, because this function has no way of knowing which characters
in the reserved set are being used for their reserved purpose and which
are part of the data. By default it assumes that they are all being used
as data, thus they all become percent-encoded.

The characters in the reserved set can be overridden from the default by
setting the reservedChars argument. The percent-encoding of characters
in the reserved set can be disabled by unsetting the encodeReserved flag.
Do this if the string is an already-assembled URI or a URI component,
such as a complete path.

If the given string is Unicode, the name of the encoding given in the
encoding argument will be used to determine the percent-encoded octets
for characters that are not in the U+0000 to U+007F range. The codec
identified by the encoding argument must return a byte string.

If the given string is not Unicode, the encoding argument is ignored and
the string is interpreted to represent literal octets, rather than
characters. Octets above \x7F will be percent-encoded as-is, e.g., \xa0
becomes %A0, not, say, %C2%A0.

The spaceToPlus flag controls whether space characters are changed to
&quot;+&quot; characters in the result, rather than being percent-encoded.
Generally, this is not required, and given the status of &quot;+&quot; as a
reserved character, is often undesirable. But it is required in certain
situations, such as when generating application/x-www-form-urlencoded
content or RFC 3151 public identifier URNs, so it is supported here.

The nlChars argument, if given, is a sequence type in which each member
is a substring that indicates a &quot;new line&quot;. Occurrences of this substring
will be replaced by '%0D%0A' in the result, as is required when generating
application/x-www-form-urlencoded content.

This function is similar to urllib.quote(), but is more conformant and
Unicode-friendly. Suggestions for improvements welcome.</description>
      <arguments>
        <arg name="s"/>
        <arg default="'utf-8'" name="encoding"/>
        <arg default="True" name="encodeReserved"/>
        <arg default="False" name="spaceToPlus"/>
        <arg default="None" name="nlChars"/>
        <arg default="&quot;/=&amp;+?#;@,:$!*[]()'&quot;" name="reservedChars"/>
      </arguments>
    </function>
    <function public="yes" name="PublicIdToUrn" id="PublicIdToUrn">
      <abstract>Converts a public identifier to a URN that conforms to RFC 3151.</abstract>
      <description/>
      <arguments>
        <arg name="publicid"/>
      </arguments>
    </function>
    <function public="yes" name="Relativize" id="Relativize">
      <abstract>This method returns a relative URI that is consistent with `targetURI`
when resolved against `againstUri`.  If no such relative URI exists, for
whatever reason, this method returns `None`.</abstract>
      <description>To be precise, if a string called `rel` exists such that
``Absolutize(rel, againstUri) == targetUri``, then `rel` is returned by
this function.  In these cases, `Relativize` is in a sense the inverse
of `Absolutize`.  In all other cases, `Relativize` returns `None`.

The following idiom may be useful for obtaining compliant relative
reference strings (e.g. for `path`) for use in other methods of this
package::

  path = Relativize(OsPathToUri(path), OsPathToUri('.'))

If `subPathOnly` is `True`, then this method will only return a relative
reference if such a reference exists relative to the last hierarchical
segment of `againstUri`.  In particular, this relative reference will
not start with '/' or '../'.</description>
      <arguments>
        <arg name="targetUri"/>
        <arg name="againstUri"/>
        <arg default="False" name="subPathOnly"/>
      </arguments>
    </function>
    <function public="yes" name="RemoveDotSegments" id="RemoveDotSegments">
      <abstract>Supports Absolutize() by implementing the remove_dot_segments function
described in RFC 3986 sec. 5.2.  It collapses most of the '.' and '..'
segments out of a path without eliminating empty segments. It is intended
to be used during the path merging process and may not give expected
results when used independently. Use NormalizePathSegments() or
NormalizePathSegmentsInUri() if more general normalization is desired.</abstract>
      <description/>
      <arguments>
        <arg name="path"/>
      </arguments>
    </function>
    <function public="no" name="ResourceToUri" id="ResourceToUri">
      <abstract>Return a PEP 302 pseudo-URL for the specified resource.</abstract>
      <description>'package' is a Python module name (dot-separated module names) and
'resource' is a '/'-separated pathname.</description>
      <arguments>
        <arg name="package"/>
        <arg name="resource"/>
      </arguments>
    </function>
    <function public="yes" name="SplitAuthority" id="SplitAuthority">
      <abstract>Given a string representing the authority component of a URI, returns
a tuple consisting of the subcomponents (userinfo, host, port). No
percent-decoding is performed.</abstract>
      <description/>
      <arguments>
        <arg name="authority"/>
      </arguments>
    </function>
    <function public="yes" name="SplitFragment" id="SplitFragment">
      <abstract>Given a URI or URI reference, returns a tuple consisting of
(base, fragment), where base is the portion before the '#' that
precedes the fragment component.</abstract>
      <description/>
      <arguments>
        <arg name="uri"/>
      </arguments>
    </function>
    <function public="yes" name="SplitUriRef" id="SplitUriRef">
      <abstract>Given a valid URI reference as a string, returns a tuple representing the
generic URI components, as per RFC 3986 appendix B. The tuple's structure
is (scheme, authority, path, query, fragment).</abstract>
      <description>All values will be strings (possibly empty) or None if undefined.

Note that per RFC 3986, there is no distinction between a path and
an &quot;opaque part&quot;, as there was in RFC 2396.</description>
      <arguments>
        <arg name="uriref"/>
      </arguments>
    </function>
    <function public="yes" name="StripFragment" id="StripFragment">
      <abstract>Returns the given URI or URI reference with the fragment component, if
any, removed.</abstract>
      <description/>
      <arguments>
        <arg name="uriRef"/>
      </arguments>
    </function>
    <function public="yes" name="UnsplitUriRef" id="UnsplitUriRef">
      <abstract>Given a sequence as would be produced by SplitUriRef(), assembles and
returns a URI reference as a string.</abstract>
      <description/>
      <arguments>
        <arg name="uriRefSeq"/>
      </arguments>
    </function>
    <function public="yes" name="UriToOsPath" id="UriToOsPath">
      <abstract>This function converts a URI reference to an OS-specific file system path.</abstract>
      <description>If the URI reference is given as a Unicode string, then the encoding
argument determines how percent-encoded components are interpreted, and
the result will be a Unicode string. If the URI reference is a regular
byte string, the encoding argument is ignored and the result will be a
byte string in which percent-encoded octets have been converted to the
bytes they represent. For example, the trailing path segment of
u'file:///a/b/%E2%80%A2' will by default be converted to u'\u2022',
because sequence E2 80 A2 represents character U+2022 in UTF-8. If the
string were not Unicode, the trailing segment would become the 3-byte
string '\xe2\x80\xa2'.

The osname argument determines for what operating system the resulting
path is appropriate. It defaults to os.name and is typically the value
'posix' on Unix systems (including Mac OS X and Cygwin), and 'nt' on
Windows NT/2000/XP.

This function is similar to urllib.url2pathname(), but is more featureful
and produces better paths.

If the given URI reference is not relative, its scheme component must be
'file', and an exception will be raised if it isn't.

In accordance with RFC 3986, RFC 1738 and RFC 1630, an authority
component that is the string 'localhost' will be treated the same as an
empty authority.

Dot segments ('.' or '..') in the path component are NOT collapsed.

If the path component of the URI reference is relative and the
attemptAbsolute flag is True (the default), then the resulting path
will be made absolute by considering the path to be relative to the
current working directory. There is no guarantee that such a result
will be an accurate interpretation of the URI reference.

attemptAbsolute has no effect if the
result is not being produced for the local operating system.

Fragment and query components of the URI reference are ignored.

If osname is 'posix', the authority component must be empty or just
'localhost'. An exception will be raised otherwise, because there is no
standard way of interpreting other authorities. Also, if '%2F' is in a
path segment, it will be converted to r'\/' (a backslash-escaped forward
slash). The caller may need to take additional steps to prevent this from
being interpreted as if it were a path segment separator.

If osname is 'nt', a drivespec is recognized as the first occurrence of a
single letter (A-Z, case-insensitive) followed by '|' or ':', occurring as
either the first segment of the path component, or (incorrectly) as the
entire authority component. A UNC hostname is recognized as a non-empty,
non-'localhost' authority component that has not been recognized as a
drivespec, or as the second path segment if the first path segment is
empty. If a UNC hostname is detected, the result will begin with
'\\&lt;hostname&gt;\'. If a drivespec was detected also, the first path segment
will be '$&lt;driveletter&gt;$'. If a drivespec was detected but a UNC hostname
was not, then the result will begin with '&lt;driveletter&gt;:'.

Windows examples:
'file:x/y/z' =&gt; r'x\y\z';
'file:/x/y/z' (not recommended) =&gt; r'\x\y\z';
'file:///x/y/z' =&gt; r'\x\y\z';
'file:///c:/x/y/z' =&gt; r'C:\x\y\z';
'file:///c|/x/y/z' =&gt; r'C:\x\y\z';
'file:///c:/x:/y/z' =&gt; r'C:\x:\y\z' (bad path, valid interpretation);
'file://c:/x/y/z' (not recommended) =&gt; r'C:\x\y\z';
'file://host/share/x/y/z' =&gt; r'\\host\share\x\y\z';
'file:////host/share/x/y/z' =&gt; r'\\host\share\x\y\z'
'file://host/x:/y/z' =&gt; r'\\host\x:\y\z' (bad path, valid interp.);
'file://localhost/x/y/z' =&gt; r'\x\y\z';
'file://localhost/c:/x/y/z' =&gt; r'C:\x\y\z';
'file:///C:%5Cx%5Cy%5Cz' (not recommended) =&gt; r'C:\x\y\z'</description>
      <arguments>
        <arg name="uri"/>
        <arg default="True" name="attemptAbsolute"/>
        <arg default="'utf-8'" name="encoding"/>
        <arg default="None" name="osname"/>
      </arguments>
    </function>
    <function public="yes" name="UrlOpen" id="UrlOpen">
      <abstract>A replacement/wrapper for urllib2.urlopen().</abstract>
      <description>Simply calls MakeUrllibSafe() on the given URL and passes the result
and all other args to urllib2.urlopen().</description>
      <arguments>
        <arg name="url"/>
        <var-args name="args"/>
        <var-keywords name="kwargs"/>
      </arguments>
    </function>
    <function public="yes" name="UrnToPublicId" id="UrnToPublicId">
      <abstract>Converts a URN that conforms to RFC 3151 to a public identifier.</abstract>
      <description>For example, the URN
&quot;urn:publicid:%2B:IDN+example.org:DTD+XML+Bookmarks+1.0:EN:XML&quot;
will be converted to the public identifier
&quot;+//IDN example.org//DTD XML Bookmarks 1.0//EN//XML&quot;

Raises a UriException if the given URN cannot be converted.
Query and fragment components, if present, are ignored.</description>
      <arguments>
        <arg name="urn"/>
      </arguments>
    </function>
    <function public="no" name="_chars" id="_chars">
      <abstract>This generator function helps iterate over the characters in a
string. When the string is unicode and a surrogate pair is
encountered, the pair is returned together, regardless of whether
Python was built with 32-bit ('wide') or 16-bit code values for
its internal representation of unicode. This function will raise a
ValueError if it detects an illegal surrogate pair.</abstract>
      <description>For example, given s = u'\ud800\udc00\U00010000',
with narrow-char unicode, &quot;for c in s&quot; normally iterates 4 times,
producing u'\ud800', u'\udc00', 'u\ud800', u'\udc00', while
&quot;for c in _chars(s)&quot; will iterate 2 times: producing
u'\ud800\udc00' both times; and with wide-char unicode,
&quot;for c in s&quot; iterates 3 times, producing u'\ud800', u'\udc00',
and u'\U00010000', while &quot;for c in _chars(s)&quot; will iterate 2 times,
producing u'\U00010000' both times.

With this function, the value yielded in each iteration is thus
guaranteed to represent a single abstract character, allowing for
ideal encoding by the built-in codecs, as is necessary when
percent-encoding.</description>
      <arguments>
        <arg name="s"/>
      </arguments>
    </function>
    <function public="no" name="_getDriveLetter" id="_getDriveLetter">
      <abstract>Called internally to get a drive letter from a string, if the string
is a drivespec.</abstract>
      <description/>
      <arguments>
        <arg name="s"/>
      </arguments>
    </function>
    <function public="no" name="_initNtPathPattern" id="_initNtPathPattern">
      <abstract>Called internally to compile the regular expression used by
OsPathToUri() on Windows just once, the first time the function is
called.</abstract>
      <description/>
      <arguments>
      </arguments>
    </function>
    <function public="no" name="_initSplitAuthorityPattern" id="_initSplitAuthorityPattern">
      <abstract>Called internally to compile the regular expression used by
SplitAuthority() just once, the first time the function is called.</abstract>
      <description/>
      <arguments>
      </arguments>
    </function>
    <function public="no" name="_initSplitUriRefPattern" id="_initSplitUriRefPattern">
      <abstract>Called internally to compile the regular expression used by
SplitUriRef() just once, the first time the function is called.</abstract>
      <description/>
      <arguments>
      </arguments>
    </function>
    <function public="no" name="_initUriValidationRegex" id="_initUriValidationRegex">
      <abstract>Called internally to compile the regular expressions needed by
URI validation functions, just once, the first time a function
that needs them is called.</abstract>
      <description/>
      <arguments>
      </arguments>
    </function>
    <function public="no" name="_splitNtPath" id="_splitNtPath">
      <abstract>Called internally to get a tuple representing components of the given
Windows path.</abstract>
      <description/>
      <arguments>
        <arg name="path"/>
      </arguments>
    </function>
  </functions>
  <globals>
    <global public="yes" name="BASIC_RESOLVER" id="BASIC_RESOLVER">
      <value>&lt;Ft.Lib.Uri.FtUriResolver instance at 0xb792abac&gt;</value>
    </global>
    <global public="yes" name="DEFAULT_URI_SCHEMES" id="DEFAULT_URI_SCHEMES">
      <value>('http', 'https', 'file', 'ftp', 'data', 'pep302')</value>
    </global>
    <global public="no" name="REG_NAME_HOST_PATTERN" id="REG_NAME_HOST_PATTERN">
      <abstract>Compiled regular expression objects</abstract>
      <description/>
      <value>&lt;_sre.SRE_Pattern object at 0xb7b9fd40&gt;</value>
    </global>
    <global public="no" name="RESERVED" id="RESERVED">
      <value>&quot;/=&amp;+?#;@,:$!*[]()'&quot;</value>
    </global>
    <global public="no" name="SCHEME_PATTERN" id="SCHEME_PATTERN">
      <abstract>Compiled regular expression objects</abstract>
      <description/>
      <value>&lt;_sre.SRE_Pattern object at 0xb7c0fe30&gt;</value>
    </global>
    <global public="no" name="SURR_DC00" id="SURR_DC00">
      <value>u'\udc00'</value>
    </global>
    <global public="no" name="UNRESERVED_PATTERN" id="UNRESERVED_PATTERN">
      <abstract>Compiled regular expression objects</abstract>
      <description/>
      <value>&lt;_sre.SRE_Pattern object at 0xb7adaf20&gt;</value>
    </global>
    <global public="yes" name="WINDOWS_SLASH_COMPAT" id="WINDOWS_SLASH_COMPAT">
      <value>True</value>
    </global>
    <global public="no" name="__all__" id="__all__">
      <value>['MatchesUriRefSyntax', 'MatchesUriSyntax', 'PercentEncode', 'PercentDecode', 'SplitUriRef', 'UnsplitUriRef', 'SplitAuthority', 'SplitFragment', 'Absolutize', 'Relativize', 'RemoveDotSegments', 'NormalizeCase', 'NormalizePercentEncoding', 'NormalizePathSegments', 'NormalizePathSegmentsInUri', 'UriResolverBase', 'FtUriResolver', 'BASIC_RESOLVER', 'DEFAULT_URI_SCHEMES', 'UrlOpen', ...]</value>
    </global>
    <global public="no" name="ascii_letters" id="ascii_letters">
      <value>'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</value>
    </global>
    <global public="no" name="generators" id="generators">
      <value>_Feature((2, 2, 0, 'alpha', 1), (2, 3, 0, 'final', 0), 0)</value>
    </global>
  </globals>
</module>
